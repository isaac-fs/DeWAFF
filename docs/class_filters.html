<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DeWAFF: Filters Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript"> DoxygenAwesomeDarkModeToggle.init() </script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DeWAFF
   </div>
   <div id="projectbrief">Deceived Weighted Average Filters Framework Image abstraction algorithm implementation in C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_filters.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_filters-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Filters Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class containing Weighted Average <a class="el" href="class_filters.html" title="Class containing Weighted Average Filters (WAFs). This implementation relies on padding the original ...">Filters</a> (WAFs). This implementation relies on padding the original image to fit square odd dimensioned kernels throughout the processing.  
 <a href="class_filters.html#details">More...</a></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Filters:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="class_filters__inherit__graph.png" border="0" usemap="#a_filters_inherit__map" alt="Inheritance graph"/></div>
<map name="a_filters_inherit__map" id="a_filters_inherit__map">
<area shape="rect" title="Class containing Weighted Average Filters (WAFs). This implementation relies on padding the original ..." alt="" coords="13,5,75,32"/>
<area shape="rect" href="class_de_w_a_f_f.html" title="Deceived Weighted Average Filters Framework class. It applies a filter where the intput is decoupled ..." alt="" coords="5,80,83,107"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Collaboration diagram for Filters:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><img src="class_filters__coll__graph.png" border="0" usemap="#a_filters_coll__map" alt="Collaboration graph"/></div>
<map name="a_filters_coll__map" id="a_filters_coll__map">
<area shape="rect" title="Class containing Weighted Average Filters (WAFs). This implementation relies on padding the original ..." alt="" coords="5,95,68,121"/>
<area shape="rect" href="class_utils.html" title="Useful tools for image processing These tools are statics objects to use them in the lifetime of the ..." alt="" coords="11,5,63,32"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a78a4c57fc753e6de4cca5c67a494afa6"><td class="memItemLeft" align="right" valign="top">Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_filters.html#a78a4c57fc753e6de4cca5c67a494afa6">BilateralFilter</a> (const Mat &amp;inputImage, const Mat &amp;weightingImage, int windowSize, double spatialSigma, double rangeSigma)</td></tr>
<tr class="memdesc:a78a4c57fc753e6de4cca5c67a494afa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a Bilateral Filter to an image. This is the decoupled version of this filter, this means that the weighting image for the filter can be different from its input image.  <a href="class_filters.html#a78a4c57fc753e6de4cca5c67a494afa6">More...</a><br /></td></tr>
<tr class="separator:a78a4c57fc753e6de4cca5c67a494afa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6faf8cd342f97cb42f303f12cf36702"><td class="memItemLeft" align="right" valign="top">Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_filters.html#aa6faf8cd342f97cb42f303f12cf36702">ScaledBilateralFilter</a> (const Mat &amp;inputImage, const Mat &amp;weightingImage, int windowSize, double spatialSigma, double rangeSigma)</td></tr>
<tr class="memdesc:aa6faf8cd342f97cb42f303f12cf36702"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a Scaled Bilateral Filter to an image. This is the decoupled version of this filter, this means that the weighting image for the filter can be different from its input image. The difference between this filter and the not scaled version is that the weighting image is pre scaled through a Gaussian low pass filter for better performance under heavy AWGN.  <a href="class_filters.html#aa6faf8cd342f97cb42f303f12cf36702">More...</a><br /></td></tr>
<tr class="separator:aa6faf8cd342f97cb42f303f12cf36702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02eafe8690dcd01dde0f81b1c5966b44"><td class="memItemLeft" align="right" valign="top">Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_filters.html#a02eafe8690dcd01dde0f81b1c5966b44">NonLocalMeansFilter</a> (const Mat &amp;inputImage, const Mat &amp;weightingImage, int windowSize, int neighborhoodSize, double rangeSigma)</td></tr>
<tr class="memdesc:a02eafe8690dcd01dde0f81b1c5966b44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a Non Local Means Filter to an image. This is the decoupled version of this filter, this means that the weighting image for the filter can be different from its input image. The algorithm used for this filter is computationally demanding.  <a href="class_filters.html#a02eafe8690dcd01dde0f81b1c5966b44">More...</a><br /></td></tr>
<tr class="separator:a02eafe8690dcd01dde0f81b1c5966b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb2156050f10f40dfafa934f8f9ded8"><td class="memItemLeft" align="right" valign="top">Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_filters.html#a9eb2156050f10f40dfafa934f8f9ded8">GuidedFilter</a> (const Mat &amp;inputImage, const Mat &amp;guidingImage, int windowSize, double rangeSigma)</td></tr>
<tr class="memdesc:a9eb2156050f10f40dfafa934f8f9ded8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a Guided Filter to an image. This is the decoupled version of this filter, this means that the weighting image for the filter can be different from its input image. In this case the weighting image is known as guiding image. This filter uses a linear algorithm, making it fast computationally.  <a href="class_filters.html#a9eb2156050f10f40dfafa934f8f9ded8">More...</a><br /></td></tr>
<tr class="separator:a9eb2156050f10f40dfafa934f8f9ded8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a585c34a07148c8a772e04fb38ae22569"><td class="memItemLeft" align="right" valign="top"><a id="a585c34a07148c8a772e04fb38ae22569"></a>
<a class="el" href="class_utils.html">Utils</a>&#160;</td><td class="memItemRight" valign="bottom"><b>lib</b></td></tr>
<tr class="separator:a585c34a07148c8a772e04fb38ae22569"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class containing Weighted Average <a class="el" href="class_filters.html" title="Class containing Weighted Average Filters (WAFs). This implementation relies on padding the original ...">Filters</a> (WAFs). This implementation relies on padding the original image to fit square odd dimensioned kernels throughout the processing. </p>

<p class="definition">Definition at line <a class="el" href="_filters_8hpp_source.html#l00030">30</a> of file <a class="el" href="_filters_8hpp_source.html">Filters.hpp</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a78a4c57fc753e6de4cca5c67a494afa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78a4c57fc753e6de4cca5c67a494afa6">&#9670;&nbsp;</a></span>BilateralFilter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Mat Filters::BilateralFilter </td>
          <td>(</td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>inputImage_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>weightingImage_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>windowSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>spatialSigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rangeSigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a Bilateral Filter to an image. This is the decoupled version of this filter, this means that the weighting image for the filter can be different from its input image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">weightingImage_</td><td>image used to calculate the kernel weight </td></tr>
    <tr><td class="paramname">inputImage_</td><td>image used as input for the filter </td></tr>
    <tr><td class="paramname">windowSize</td><td>processing window size </td></tr>
    <tr><td class="paramname">spatialSigma</td><td>spatial standard deviation </td></tr>
    <tr><td class="paramname">rangeSigma</td><td>range or radiometric standard deviation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Mat output image </dd></dl>
<p>This filter uses two Gaussian kernels, one of them is the spatial Gaussian kernel: </p><p class="formulaDsp">
\[ G_{\text spatial}(U, m, p) = \exp\left(-\frac{ ||m - p||^2 }{ 2 {\sigma_s^2} } \right) \]
</p>
<p> with the spatial values from an image region \( \Omega \subseteq U \). The spatial kernel uses the \( m_i \subset \Omega \) pixels coordinates as weighting values for the pixel \( p = (x, y) \).</p>
<p>The other used kernel is the range Gaussian kernel: </p><p class="formulaDsp">
\[ G_{\text range}(U, m, p) = \exp\left( -\frac{ ||U(m) - U(p)||^2 }{ 2{\sigma_r^2} } \right) \]
</p>
<p> with the intensity (range) values from an image region \( \Omega \subseteq U \). The range kernel uses the \( m_i \subset \Omega \) pixels intensities as weighting values for the pixel \( p = (x, y) \) instead of their locations as in the spatial kernel computation. In this case a the input \( U \) is separated into the three CIELab weightChannels and each channel is processed as an individual input \( U_{\text channel} \).</p>
<p>The two kernels convolve to obtain the Bilateral Filter kernel: </p><p class="formulaDsp">
\[ \phi_{\text BF}(U, m, p) = G_{\text spatial}(||m-p||^2) \, G_{\text range}(||U(m)-U(p)||^2) \]
</p>
<p>The Bilateral filter's norm corresponds to: </p><p class="formulaDsp">
\[ \left( \sum_{m \subset \Omega} \phi_{\text{BF}}(U, m, p) \right)^{-1} \]
</p>
<p>Finally the bilateral filter kernel can be convolved with the input as follows: </p><p class="formulaDsp">
\[ Y_{\phi_{\text BF}}(p) = \left( \sum_{m \subset \Omega} \phi_{\text BF}(U, m, p) \right)^{-1} \left( \sum_{m \subset \Omega} \phi_{\text BF}(U, p, m) \, U(m) \right) \]
</p>

<p class="definition">Definition at line <a class="el" href="_filters_8cpp_source.html#l00014">14</a> of file <a class="el" href="_filters_8cpp_source.html">Filters.cpp</a>.</p>

</div>
</div>
<a id="a9eb2156050f10f40dfafa934f8f9ded8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eb2156050f10f40dfafa934f8f9ded8">&#9670;&nbsp;</a></span>GuidedFilter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Mat Filters::GuidedFilter </td>
          <td>(</td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>inputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>guidingImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>windowSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rangeSigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a Guided Filter to an image. This is the decoupled version of this filter, this means that the weighting image for the filter can be different from its input image. In this case the weighting image is known as guiding image. This filter uses a linear algorithm, making it fast computationally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputImage</td><td>image used as input for the filter </td></tr>
    <tr><td class="paramname">guidingImage</td><td>image used to calculate the kernel's weight </td></tr>
    <tr><td class="paramname">windowSize</td><td>processing window size </td></tr>
    <tr><td class="paramname">rangeSigma</td><td>range or radiometric standard deviation. Used to calculate \( \epsilon = \sigma_r^2 \) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Mat </dd></dl>
<p>The Guided Filter initialy has the same form as any WAF </p><p class="formulaDsp">
\[ q_i = \sum_j W_{ij}(I)p_j \]
</p>
<p> where \( q_i \) is the output if filtered pixel \( p_j \) with the kernel \( W_{ij} \) guided by image \( I \). This is expected as the original idea for this filter comes from the bilateral filter. The greatness in this filter lies in its solution. It asumes a linear relationship: </p><p class="formulaDsp">
\[ q_i = a_k I_i + b_k, \forall i \in \omega_k \]
</p>
<p> where \( \omega_k \) is a window centered at pixel \( k \). The solution is in finding the linear coefficients \( a_k \) and \( b_k \). This is achieved through the cost function </p><p class="formulaDsp">
\[ E(a_k, b_k) \sum_{i\in \omega_k} ((a_k I_i + b_k - p_i)^2 + \epsilon a_k^2)\]
</p>
<p> which seeks to minimize the difference between the input \( p \) and the output \( q \). The solution is found through a linear regresion </p><p class="formulaDsp">
\[ a_k = \frac{\frac{1}{|\omega|} \sum_{i\in \omega_k} I_i p_i - \mu_k \bar{p}_k}{\omega_k^2 + \epsilon}\]
</p>
 <p class="formulaDsp">
\[ b_k = \bar{p}_k - a_k \mu_k \]
</p>
<p> \( \mu_k \) and \(\omega_k^2\) are the mean and the variance of \(I\) in \( \omega_k \), respectively. \( \frac{1}{|\omega|} \sum_{i\in \omega_k} p_i \) is the mean of \(p\) in \( \omega_k \). Finally the output of the filter is </p><p class="formulaDsp">
\[ q_i = \frac{1}{|\omega|} \sum_{k:i \in \omega_k} (a_k I_i + b_k )\]
</p>

<p class="definition">Definition at line <a class="el" href="_filters_8cpp_source.html#l00281">281</a> of file <a class="el" href="_filters_8cpp_source.html">Filters.cpp</a>.</p>

</div>
</div>
<a id="a02eafe8690dcd01dde0f81b1c5966b44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02eafe8690dcd01dde0f81b1c5966b44">&#9670;&nbsp;</a></span>NonLocalMeansFilter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Mat Filters::NonLocalMeansFilter </td>
          <td>(</td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>inputImage_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>weightingImage_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>windowSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>neighborhoodSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rangeSigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a Non Local Means Filter to an image. This is the decoupled version of this filter, this means that the weighting image for the filter can be different from its input image. The algorithm used for this filter is computationally demanding. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">weightingImage_</td><td>image used to calculate the kernel's weight </td></tr>
    <tr><td class="paramname">inputImage_</td><td>image used as input for the filter </td></tr>
    <tr><td class="paramname">windowSize</td><td>processing window size </td></tr>
    <tr><td class="paramname">neighborhoodSize</td><td>subwindow size </td></tr>
    <tr><td class="paramname">rangeSigma</td><td>range or radiometric standard deviation. Used to calculate the parameter \( h^2 = 2 \sigma_r^2 \) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Mat output image </dd></dl>
<p>The discrete representation of the Non Local Means Filter is as follows: </p><p class="formulaDsp">
\[ \phi_{\text {NLM}}(U, m, p) = \sum_{B(m) \subseteq U} \exp\left( \frac{||B(m) - B(p)||^2}{h^2} \right)\]
</p>
<p> where \(B(p)\) is a patch part of the window \(\Omega\) centered at pixel \(p\). \(B(m)\) represents all of the patches at \(\Omega\) centered in each \(m\) pixel. The Non Local Means Filter calculates the Euclidean distance between each patch \(B(m)\) and \(B(p)\) for each window \(\Omega \subseteq U\). This is why this algorithm is demanding in computational terms. Each Euclidean distance matrix obtained from each patch pair is the input for a Gaussian decreasing function with standard deviation \(h\) that generates the new pixel \(p\) value.</p>
<p>The Non Local Means filter's norm is calculated with: </p><p class="formulaDsp">
\[\left( \sum_{m \subset \Omega} \phi_{\text{NLM}}(U, m, p) \right)^{-1} \]
</p>
<p>The NLM filter kernel is applied to the laplacian image: </p><p class="formulaDsp">
\[ Y_{\phi_{\text NLM}}(p) = \left( \sum_{m \subset \Omega} \phi_{\text NLM}(U, m, p) \right)^{-1} \left( \sum_{m \subset \Omega} \phi_{\text NLM}(U, p, m) \, U(m) \right) \]
</p>

<p class="definition">Definition at line <a class="el" href="_filters_8cpp_source.html#l00183">183</a> of file <a class="el" href="_filters_8cpp_source.html">Filters.cpp</a>.</p>

</div>
</div>
<a id="aa6faf8cd342f97cb42f303f12cf36702"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6faf8cd342f97cb42f303f12cf36702">&#9670;&nbsp;</a></span>ScaledBilateralFilter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Mat Filters::ScaledBilateralFilter </td>
          <td>(</td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>inputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>weightingImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>windowSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>spatialSigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rangeSigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a Scaled Bilateral Filter to an image. This is the decoupled version of this filter, this means that the weighting image for the filter can be different from its input image. The difference between this filter and the not scaled version is that the weighting image is pre scaled through a Gaussian low pass filter for better performance under heavy AWGN. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">weightingImage</td><td>image used to calculate the kernel's weight </td></tr>
    <tr><td class="paramname">inputImage</td><td>image used as input for the filter </td></tr>
    <tr><td class="paramname">windowSize</td><td>processing window size, has to be odd numbered and greater or equal than 3 </td></tr>
    <tr><td class="paramname">spatialSigma</td><td>spatial standard deviation </td></tr>
    <tr><td class="paramname">rangeSigma</td><td>range or radiometric standard deviation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Mat output image </dd></dl>
<p>It uses the two same Gaussian kernels as the bilateral filter, but it has an extra input, the scaled image \( U^s \). The kernels are the following: </p><p class="formulaDsp">
\[ G_{\text spatial}(U^s, U, m, p) = \exp\left(-\frac{ ||m - p||^2 }{ 2 {\sigma_s^2} } \right) \]
</p>
 <p class="formulaDsp">
\[ G_{\text range}(U^s, U, m, p) = \exp\left( -\frac{ ||U^s(m) - U(p)||^2 }{ 2{\sigma_r^2} } \right) \]
</p>
<p> Notice the diferrence on the range kernel calculation where the scaled image is used.</p>
<p>The two kernels convolve to obtain the Bilateral Filter kernel: </p><p class="formulaDsp">
\[ \phi_{\text SBF}(U^s, U, m, p) = G_{\text spatial}(||m-p||^2) \, G_{\text range}(||U^s(m)-U(p)||^2) \]
</p>
<p>The Bilateral filter's norm corresponds to: </p><p class="formulaDsp">
\[ \left( \sum_{m \subset \Omega} \phi_{\text{SBF}}(U^s, U, m, p) \right)^{-1} \]
</p>
<p>Finally the bilateral filter kernel can be convolved with the input as follows: </p><p class="formulaDsp">
\[ Y_{\phi_{\text SBF}}(p) = \left( \sum_{m \subset \Omega} \phi_{\text SBF}(U^s, U, m, p) \right)^{-1} \left( \sum_{m \subset \Omega} \phi_{\text SBF}(U^s, U, m, p) \, U(m) \right) \]
</p>

<p class="definition">Definition at line <a class="el" href="_filters_8cpp_source.html#l00135">135</a> of file <a class="el" href="_filters_8cpp_source.html">Filters.cpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_filters_8hpp_source.html">Filters.hpp</a></li>
<li><a class="el" href="_filters_8cpp_source.html">Filters.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_filters.html">Filters</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>

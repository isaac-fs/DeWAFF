<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DeWAFF: Filter Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DeWAFF
   </div>
   <div id="projectbrief">Deceived Weighted Average Filters Framework Image abstraction algorithm implementation in C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_filter.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="class_filter-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Filter Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class containing Weighted Average Filters (WAFs). This implementation relies on padding the original image to fit square odd dimensioned kernels throughout the processing.  
 <a href="class_filter.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_filter_8hpp_source.html">Filter.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Filter:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_filter.png" usemap="#Filter_map" alt=""/>
  <map id="Filter_map" name="Filter_map">
<area href="class_de_w_a_f_f.html" title="Deceived Weighted Average Filters Framework class It applies a filter which intput and weighting inpu..." alt="DeWAFF" shape="rect" coords="0,56,64,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9850745e2c33c0b338890552a8b1657c"><td class="memItemLeft" align="right" valign="top">Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_filter.html#a9850745e2c33c0b338890552a8b1657c">BilateralFilter</a> (const Mat &amp;weightingImage, const Mat &amp;inputImage, const int windowSize, const double spatialSigma, const int rangeSigma)</td></tr>
<tr class="memdesc:a9850745e2c33c0b338890552a8b1657c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a Bilateral <a class="el" href="class_filter.html" title="Class containing Weighted Average Filters (WAFs). This implementation relies on padding the original ...">Filter</a> to an image. This is the decoupled version of this filter, this means that the weighting image for the filter can be different from the input image.  <a href="class_filter.html#a9850745e2c33c0b338890552a8b1657c">More...</a><br /></td></tr>
<tr class="separator:a9850745e2c33c0b338890552a8b1657c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa49af5e7dd383c0f64d761eb7ca799ea"><td class="memItemLeft" align="right" valign="top">Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_filter.html#aa49af5e7dd383c0f64d761eb7ca799ea">ScaledBilateralFilter</a> (const Mat &amp;weightingImage, const Mat &amp;inputImage, const int windowSize, const double spatialSigma, const int rangeSigma)</td></tr>
<tr class="memdesc:aa49af5e7dd383c0f64d761eb7ca799ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a Scaled Bilateral <a class="el" href="class_filter.html" title="Class containing Weighted Average Filters (WAFs). This implementation relies on padding the original ...">Filter</a> to an image. This is the decoupled version of this filter, this means that the weighting image for the filter can be different from the input image. The difference between this filter and the not scaled version is that the weighting image is pre scaled through a Gaussian low pass filter to have better performance under heavy AWGN.  <a href="class_filter.html#aa49af5e7dd383c0f64d761eb7ca799ea">More...</a><br /></td></tr>
<tr class="separator:aa49af5e7dd383c0f64d761eb7ca799ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d447e30142261e65476e940227cf2b4"><td class="memItemLeft" align="right" valign="top">Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_filter.html#a7d447e30142261e65476e940227cf2b4">NonLocalMeansFilter</a> (const Mat &amp;weightingImage, const Mat &amp;inputImage, const int windowSize, const int patchSize, const double rangeSigma)</td></tr>
<tr class="memdesc:a7d447e30142261e65476e940227cf2b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a Non Local Means <a class="el" href="class_filter.html" title="Class containing Weighted Average Filters (WAFs). This implementation relies on padding the original ...">Filter</a> to an image. This is the decoupled version of this filter, this means that the weighting image for the filter can be different from the input image. The algorithm used for this filter is very computationally demanding.  <a href="class_filter.html#a7d447e30142261e65476e940227cf2b4">More...</a><br /></td></tr>
<tr class="separator:a7d447e30142261e65476e940227cf2b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5207fd86afc6201dc53ec0dc6892cc50"><td class="memItemLeft" align="right" valign="top"><a id="a5207fd86afc6201dc53ec0dc6892cc50"></a>
Mat&#160;</td><td class="memItemRight" valign="bottom"><b>GuidedFilter</b> (const Mat &amp;inputImage, const Mat &amp;guidingImage, const int windowSize, const int rangeSigma)</td></tr>
<tr class="separator:a5207fd86afc6201dc53ec0dc6892cc50"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ad6382618e9f9b60f9d66106965a0027c"><td class="memItemLeft" align="right" valign="top"><a id="ad6382618e9f9b60f9d66106965a0027c"></a>
<a class="el" href="class_utils.html">Utils</a>&#160;</td><td class="memItemRight" valign="bottom"><b>lib</b></td></tr>
<tr class="separator:ad6382618e9f9b60f9d66106965a0027c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:ab9a61a4434b20514b4c0cb4541f26c61"><td class="memItemLeft" align="right" valign="top"><a id="ab9a61a4434b20514b4c0cb4541f26c61"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>CIELab</b> : int { <b>L</b>
, <b>a</b>
, <b>b</b>
 }</td></tr>
<tr class="separator:ab9a61a4434b20514b4c0cb4541f26c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class containing Weighted Average Filters (WAFs). This implementation relies on padding the original image to fit square odd dimensioned kernels throughout the processing. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a9850745e2c33c0b338890552a8b1657c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9850745e2c33c0b338890552a8b1657c">&#9670;&nbsp;</a></span>BilateralFilter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Mat Filter::BilateralFilter </td>
          <td>(</td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>weightingImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>inputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>windowSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>spatialSigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>rangeSigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a Bilateral <a class="el" href="class_filter.html" title="Class containing Weighted Average Filters (WAFs). This implementation relies on padding the original ...">Filter</a> to an image. This is the decoupled version of this filter, this means that the weighting image for the filter can be different from the input image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">weightingImage</td><td>image used to calculate the kernel's weight </td></tr>
    <tr><td class="paramname">inputImage</td><td>image used as input for the filter </td></tr>
    <tr><td class="paramname">windowSize</td><td>processing window size, has to be odd numbered and greater or equal than 3 </td></tr>
    <tr><td class="paramname">spatialSigma</td><td>spatial standard deviation </td></tr>
    <tr><td class="paramname">rangeSigma</td><td>range or radiometric standard deviation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Mat output image </dd></dl>
<p>Compute a spatial Gaussian kernel \( G_{\text spatial}(U, m, p) = \exp\left(-\frac{ ||m - p||^2 }{ 2 {\sigma_s^2} } \right) \) with the spatial values (pixel positions) from an image region \( \Omega \subseteq U \). The spatial kernel uses the \( m_i \subseteq \Omega \) pixels coordinates as weighting values for the pixel \( p = (x, y) \). Normalize it with \(\frac{1}{\sum G_{\text kernel}}\) so it sums to 1 for low pass filter behavior consistency</p>
<p>Compute a range Gaussian kernel \( G_{\text range}(U, m, p) = \exp\left( -\frac{ |U(m) - U(p)|^2 }{ 2{\sigma_s^2} } \right) \) with the range values (pixel intensities) from an input weightRegion \( \Omega \subseteq U \). The range kernel uses the \( m_i \subseteq \Omega \) pixels intensities as weighting values for the pixel \( p = (x, y) \) instead of their locations as in the spatial kernel computation. In this case a the input \( U \) is separated into the three CIELab weightChannels and each channel is processed as an individual input \( U_{\text channel} \)</p>
<p>Convolve the spatial and range gaussian kernels to obtain the bilateral filter kernel \( \phi_{\text SBF}(U, m, p) = G_{\text spatial}(|m-p|) \, G_{\text range}(|U(m)-U(p)|) \)</p>
<p>Calculate the Bilateral filter's norm \( \left( \sum_{m \subseteq \Omega} \phi_{\text{SBF}}(U, m, p) \right)^{-1} \)</p>
<p>Apply the bilateral filter kernel to the laplacian input: \( Y_{\phi_{\text SBF}}(p) = \left( \sum_{m \subseteq \Omega} \phi_{\text SBF}(U, m, p) \right)^{-1} \left( \sum_{m \subseteq \Omega} \phi_{\text SBF}(U, p, m) \, \hat{f}_{\text USM}(m) \right) \)</p>

</div>
</div>
<a id="a7d447e30142261e65476e940227cf2b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d447e30142261e65476e940227cf2b4">&#9670;&nbsp;</a></span>NonLocalMeansFilter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Mat Filter::NonLocalMeansFilter </td>
          <td>(</td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>weightingImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>inputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>windowSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>patchSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>rangeSigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a Non Local Means <a class="el" href="class_filter.html" title="Class containing Weighted Average Filters (WAFs). This implementation relies on padding the original ...">Filter</a> to an image. This is the decoupled version of this filter, this means that the weighting image for the filter can be different from the input image. The algorithm used for this filter is very computationally demanding. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">weightingImage</td><td>image used to calculate the kernel's weight </td></tr>
    <tr><td class="paramname">inputImage</td><td>image used as input for the filter </td></tr>
    <tr><td class="paramname">windowSize</td><td>processing window size, has to be odd numbered and greater or equal than 3 </td></tr>
    <tr><td class="paramname">rangeSigma</td><td>range or radiometric standard deviation. Used to calculate \( h = \frac{\sqrt(\sigma)}{2} \) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Mat output image </dd></dl>
<p>Compute the Non Local Means <a class="el" href="class_filter.html" title="Class containing Weighted Average Filters (WAFs). This implementation relies on padding the original ...">Filter</a> \( \phi_{\text {NLM}}(U, m, p) = \sum_{B(m) \subseteq U} \exp\left( \frac{|B(m) - B(p)|^2}{h^2} \right)\) where \(B(p)\) is a patch of the window \(\Omega\) centered at pixel \(p\). \(B(m)\) is the rest of the patches in \(\Omega\) centered at each \(m\) pixel. The Non Local Means <a class="el" href="class_filter.html" title="Class containing Weighted Average Filters (WAFs). This implementation relies on padding the original ...">Filter</a> calculates the Euclidean distance between each patch \(B(m)\) and \(B(p)\) for each window \(\Omega \subseteq U\). This is why this algorithm is highly demanding in computational terms. Each Euclidean distance matrix obtained from each patch pair is the input for a Gaussian decreasing function with standard deviation \(h\) that generates the new pixel \(p\) value</p>
<p>Calculate the Non Local Means filter's norm \( \phi_{\text NLM}(U, m, p) \left( \sum_{m \subseteq \Omega} \phi_{\text{NLM}}(U, m, p) \right)^{-1} \)</p>
<p>Apply the NLM filter kernel to the laplacian image. \( Y_{\phi_{\text NLM}}(p) = \left( \sum_{m \subseteq \Omega} \phi_{\text NLM}(U, m, p) \right)^{-1} \left( \sum_{m \subseteq \Omega} \phi_{\text NLM}(U, p, m) \, \hat{f}_{\text USM}(m) \right) \)</p>

</div>
</div>
<a id="aa49af5e7dd383c0f64d761eb7ca799ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa49af5e7dd383c0f64d761eb7ca799ea">&#9670;&nbsp;</a></span>ScaledBilateralFilter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Mat Filter::ScaledBilateralFilter </td>
          <td>(</td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>weightingImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>inputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>windowSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>spatialSigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>rangeSigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a Scaled Bilateral <a class="el" href="class_filter.html" title="Class containing Weighted Average Filters (WAFs). This implementation relies on padding the original ...">Filter</a> to an image. This is the decoupled version of this filter, this means that the weighting image for the filter can be different from the input image. The difference between this filter and the not scaled version is that the weighting image is pre scaled through a Gaussian low pass filter to have better performance under heavy AWGN. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">weightingImage</td><td>image used to calculate the kernel's weight </td></tr>
    <tr><td class="paramname">inputImage</td><td>image used as input for the filter </td></tr>
    <tr><td class="paramname">windowSize</td><td>processing window size, has to be odd numbered and greater or equal than 3 </td></tr>
    <tr><td class="paramname">spatialSigma</td><td>spatial standard deviation </td></tr>
    <tr><td class="paramname">rangeSigma</td><td>range or radiometric standard deviation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Mat output image </dd></dl>
<p>Compute a range Gaussian kernel \( G_{\text range}(U, U^s, m, p) = \exp\left( -\frac{ |U^s(m) - U(p)|^2 }{ 2{\sigma_s^2} } \right) \) with the range values (pixel intensities) from an image region \( \Omega \subseteq U \). The range kernel uses the \( m_i \subseteq \Omega \) pixels intensities as weighting values for the pixel \( p = (x, y) \) instead of their locations as in the spatial kernel computation. In this case a the image \( U \) is separated into the three CIELab scaledChannels and each channel is processed as an individual image \( U_{\text channel} \)</p>
<p>Convolve the spatial and range gaussian kernels to obtain the bilateral filter kernel \( \phi_{\text SBF}(U, U^s, m, p) = G_{\text spatial}(|m-p|) \, G_{\text range}(|U^s(m)-U(p)|) \)</p>
<p>Calculate the Bilateral filter's norm \( \left( \sum_{m \subseteq \Omega} \phi_{\text{SBF}}(U, U^s, m, p) \right)^{-1} \)</p>
<p>Apply the bilateral filter kernel to the laplacian image. The Laplacian deceive consists on weighting the Bilateral <a class="el" href="class_filter.html" title="Class containing Weighted Average Filters (WAFs). This implementation relies on padding the original ...">Filter</a> kernel with the original image and use the USM image as input for the filter \( Y_{\phi_{\text SBF}}(p) = \left( \sum_{m \subseteq \Omega} \phi_{\text SBF}(U, U^s, m, p) \right)^{-1} \left( \sum_{m \subseteq \Omega} \phi_{\text SBF}(U, p, m) \, \hat{f}_{\text USM}(m) \right) \)</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/isaac/Desktop/DeWAFF/include/<a class="el" href="_filter_8hpp_source.html">Filter.hpp</a></li>
<li>/home/isaac/Desktop/DeWAFF/src/Filter.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_filter.html">Filter</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>

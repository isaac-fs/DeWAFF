\hypertarget{class_utils}{}\doxysubsection{Utils Class Reference}
\label{class_utils}\index{Utils@{Utils}}


Useful tools for image processing These tools are statics objects to use them in the lifetime of the program without the need of constinuous instantiation.  




{\ttfamily \#include $<$Utils.\+hpp$>$}



Inheritance diagram for Utils\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=125pt]{class_utils__inherit__graph}
\end{center}
\end{figure}
\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{class_utils_acebbcc4ea191555ab087d05145edd3cc}{Mesh\+Grid}} (const Range \&range, Mat \&X, Mat \&Y)
\begin{DoxyCompactList}\small\item\em Generates a meshgrid from $X$ and $Y$ unidimensional coordinates Example\+: x\+Range = \mbox{[}0,3\mbox{[} and y\+Range = \mbox{[}0,3\mbox{[} will return the following $X$ and $Y$ coordinates. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_utils_a012b8177e7e05918d805620bf736ee9f}{Min\+Max}} (const Mat \&A, double $\ast$minA, double $\ast$maxA)
\begin{DoxyCompactList}\small\item\em Gets the global min and max values of a 3 channel Matrix. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_utils_aaed701e60ee9310481dcf1c5758aed77}\label{class_utils_aaed701e60ee9310481dcf1c5758aed77}} 
Mat {\bfseries Gaussian\+Function} (Mat input, double sigma)
\item 
Mat \mbox{\hyperlink{class_utils_a94be617a9fa88444e5be1a0da341669f}{Gaussian\+Kernel}} (int window\+Size, double sigma)
\begin{DoxyCompactList}\small\item\em Computes a spatial Gaussian kernel $ G(X, Y) = \exp\left(-\frac{|X + Y|^2 }{ 2 {\sigma_s^2} } \right) $ where X + Y are the horizontal and vertical coordinates on a $ \text{windowSize} \times \text{windowSize} $ 2D plane. The result can be interpreted as looking at a Gaussian distribution from a top view. \end{DoxyCompactList}\item 
Mat \mbox{\hyperlink{class_utils_a33e004a9e2d65706d5aeee81c3a35b8b}{Lo\+GKernel}} (int window\+Size, double sigma)
\begin{DoxyCompactList}\small\item\em Computes a Laplacian of Gaussian kernel. Same as fspecial(\textquotesingle{}log\textquotesingle{},..) in Matlab. $ \text{LoG}_{\text kernel} = - \frac{1}{\pi \sigma^4} \left[ 1 - \frac{X^2 + Y^2}{2 \sigma^2} \right] \exp\left(-\frac{X^2 + Y^2}{2 \sigma^2}\right) $ and normalize it with $ \frac{\sum \text{LoG} }{|\text{LoG}|}$ where $ |\text{LoG}| $ is the number of elements in $ \text{LoG} $ so it sums to 0 for high pass filter behavior consistency. \end{DoxyCompactList}\item 
Mat \mbox{\hyperlink{class_utils_a2f186a4cf3bafaa09b6cf14c23f9cfae}{Non\+Adaptive\+USM}} (const Mat \&image, int window\+Size, int lambda, double sigma)
\begin{DoxyCompactList}\small\item\em Applies a regular non adaptive Un\+Sharp mask (USM) with a Laplacian of Gaussian kernel $ \hat{f}_{\text USM} = U + \lambda \mathcal{L} \text{ where } \mathcal{L} = l * g $. Here $ g $ is a Gaussian kernel and $ l $ a Laplacian kernel, hence the name \char`\"{}\+Laplacian of Gaussian\char`\"{}. \end{DoxyCompactList}\item 
Mat \mbox{\hyperlink{class_utils_a23e29d1c22b01cdfa199ca8b5812755e}{Euclidean\+Distance\+Matrix}} (const Mat \&image, int patch\+Size)
\begin{DoxyCompactList}\small\item\em Computes an Euclidean distance matrix from an input matrix. This is achieved by calculating the Euclidean distance between a fixed patch at the center of the input image and a patch centered in every other pixel in the input image, mathematically, for an input matrix $A = (a_{ij})$ every element will take the corresponding Euclidean distance value $a_{ij} = d_{ij}^{2} = || x_{i}-x_{j} ||^{2}$. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsubsection{Detailed Description}
Useful tools for image processing These tools are statics objects to use them in the lifetime of the program without the need of constinuous instantiation. 

\doxysubsubsection{Member Function Documentation}
\mbox{\Hypertarget{class_utils_a23e29d1c22b01cdfa199ca8b5812755e}\label{class_utils_a23e29d1c22b01cdfa199ca8b5812755e}} 
\index{Utils@{Utils}!EuclideanDistanceMatrix@{EuclideanDistanceMatrix}}
\index{EuclideanDistanceMatrix@{EuclideanDistanceMatrix}!Utils@{Utils}}
\doxyparagraph{\texorpdfstring{EuclideanDistanceMatrix()}{EuclideanDistanceMatrix()}}
{\footnotesize\ttfamily Mat Utils\+::\+Euclidean\+Distance\+Matrix (\begin{DoxyParamCaption}\item[{const Mat \&}]{input\+Image,  }\item[{int}]{patch\+Size }\end{DoxyParamCaption})}



Computes an Euclidean distance matrix from an input matrix. This is achieved by calculating the Euclidean distance between a fixed patch at the center of the input image and a patch centered in every other pixel in the input image, mathematically, for an input matrix $A = (a_{ij})$ every element will take the corresponding Euclidean distance value $a_{ij} = d_{ij}^{2} = || x_{i}-x_{j} ||^{2}$. 


\begin{DoxyParams}{Parameters}
{\em input\+Image} & input image to obtain the patches to compute the matrix \\
\hline
{\em patch\+Size} & size of the used patch. Analog to window size \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Mat Euclidean distance matrix 
\end{DoxyReturn}
\mbox{\Hypertarget{class_utils_a94be617a9fa88444e5be1a0da341669f}\label{class_utils_a94be617a9fa88444e5be1a0da341669f}} 
\index{Utils@{Utils}!GaussianKernel@{GaussianKernel}}
\index{GaussianKernel@{GaussianKernel}!Utils@{Utils}}
\doxyparagraph{\texorpdfstring{GaussianKernel()}{GaussianKernel()}}
{\footnotesize\ttfamily Mat Utils\+::\+Gaussian\+Kernel (\begin{DoxyParamCaption}\item[{int}]{window\+Size,  }\item[{double}]{sigma }\end{DoxyParamCaption})}



Computes a spatial Gaussian kernel $ G(X, Y) = \exp\left(-\frac{|X + Y|^2 }{ 2 {\sigma_s^2} } \right) $ where X + Y are the horizontal and vertical coordinates on a $ \text{windowSize} \times \text{windowSize} $ 2D plane. The result can be interpreted as looking at a Gaussian distribution from a top view. 


\begin{DoxyParams}{Parameters}
{\em window\+Size} & 2D plane dimension \\
\hline
{\em sigma} & standar deviation for the Gaussian distribution \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Mat A Gaussian kernel 
\end{DoxyReturn}
Pre computates the spatial Gaussian kernel Calculate the kernel variable $ S = X^2 + Y^2 $\mbox{\Hypertarget{class_utils_a33e004a9e2d65706d5aeee81c3a35b8b}\label{class_utils_a33e004a9e2d65706d5aeee81c3a35b8b}} 
\index{Utils@{Utils}!LoGKernel@{LoGKernel}}
\index{LoGKernel@{LoGKernel}!Utils@{Utils}}
\doxyparagraph{\texorpdfstring{LoGKernel()}{LoGKernel()}}
{\footnotesize\ttfamily Mat Utils\+::\+Lo\+GKernel (\begin{DoxyParamCaption}\item[{int}]{window\+Size,  }\item[{double}]{sigma }\end{DoxyParamCaption})}



Computes a Laplacian of Gaussian kernel. Same as fspecial(\textquotesingle{}log\textquotesingle{},..) in Matlab. $ \text{LoG}_{\text kernel} = - \frac{1}{\pi \sigma^4} \left[ 1 - \frac{X^2 + Y^2}{2 \sigma^2} \right] \exp\left(-\frac{X^2 + Y^2}{2 \sigma^2}\right) $ and normalize it with $ \frac{\sum \text{LoG} }{|\text{LoG}|}$ where $ |\text{LoG}| $ is the number of elements in $ \text{LoG} $ so it sums to 0 for high pass filter behavior consistency. 

Pre computates the spatial Gaussian kernel Calculate the kernel variable $ S = X^2 + Y^2 $\mbox{\Hypertarget{class_utils_acebbcc4ea191555ab087d05145edd3cc}\label{class_utils_acebbcc4ea191555ab087d05145edd3cc}} 
\index{Utils@{Utils}!MeshGrid@{MeshGrid}}
\index{MeshGrid@{MeshGrid}!Utils@{Utils}}
\doxyparagraph{\texorpdfstring{MeshGrid()}{MeshGrid()}}
{\footnotesize\ttfamily void Utils\+::\+Mesh\+Grid (\begin{DoxyParamCaption}\item[{const Range \&}]{range,  }\item[{Mat \&}]{X,  }\item[{Mat \&}]{Y }\end{DoxyParamCaption})}



Generates a meshgrid from $X$ and $Y$ unidimensional coordinates Example\+: x\+Range = \mbox{[}0,3\mbox{[} and y\+Range = \mbox{[}0,3\mbox{[} will return the following $X$ and $Y$ coordinates. 

$X$ = ~\newline
 \mbox{[}0, 0, 0; ~\newline
 1, 1, 1; ~\newline
 2, 2, 2\mbox{]} ~\newline
 $Y$ = ~\newline
 \mbox{[}0, 1, 2; ~\newline
 0, 1, 2; ~\newline
 0, 1, 2\mbox{]} ~\newline
 ~\newline
Wich would form the following mesh grid

$(X,Y)$ = ~\newline
 \mbox{[}(0,0) (0,1), (0,2); ~\newline
 (0,1) (1,1), (2,1); ~\newline
 (2,0) (2,1), (2,2)\mbox{]}


\begin{DoxyParams}{Parameters}
{\em range} & range to form the 2D grid \\
\hline
{\em X} & x axis values for the mesh grid \\
\hline
{\em Y} & y axis values for the mesh grid \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_utils_a012b8177e7e05918d805620bf736ee9f}\label{class_utils_a012b8177e7e05918d805620bf736ee9f}} 
\index{Utils@{Utils}!MinMax@{MinMax}}
\index{MinMax@{MinMax}!Utils@{Utils}}
\doxyparagraph{\texorpdfstring{MinMax()}{MinMax()}}
{\footnotesize\ttfamily void Utils\+::\+Min\+Max (\begin{DoxyParamCaption}\item[{const Mat \&}]{A,  }\item[{double $\ast$}]{minA,  }\item[{double $\ast$}]{maxA }\end{DoxyParamCaption})}



Gets the global min and max values of a 3 channel Matrix. 


\begin{DoxyParams}{Parameters}
{\em A} & Input matrix \\
\hline
{\em minA} & Minimun value of the matrix A \\
\hline
{\em maxA} & Maximun value of the matrix A \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_utils_a2f186a4cf3bafaa09b6cf14c23f9cfae}\label{class_utils_a2f186a4cf3bafaa09b6cf14c23f9cfae}} 
\index{Utils@{Utils}!NonAdaptiveUSM@{NonAdaptiveUSM}}
\index{NonAdaptiveUSM@{NonAdaptiveUSM}!Utils@{Utils}}
\doxyparagraph{\texorpdfstring{NonAdaptiveUSM()}{NonAdaptiveUSM()}}
{\footnotesize\ttfamily Mat Utils\+::\+Non\+Adaptive\+USM (\begin{DoxyParamCaption}\item[{const Mat \&}]{image,  }\item[{int}]{window\+Size,  }\item[{int}]{lambda,  }\item[{double}]{sigma }\end{DoxyParamCaption})}



Applies a regular non adaptive Un\+Sharp mask (USM) with a Laplacian of Gaussian kernel $ \hat{f}_{\text USM} = U + \lambda \mathcal{L} \text{ where } \mathcal{L} = l * g $. Here $ g $ is a Gaussian kernel and $ l $ a Laplacian kernel, hence the name \char`\"{}\+Laplacian of Gaussian\char`\"{}. 


\begin{DoxyParams}{Parameters}
{\em image} & Image to apply the mask \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Filtered image 
\end{DoxyReturn}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
include/\mbox{\hyperlink{_utils_8hpp}{Utils.\+hpp}}\item 
src/Utils.\+cpp\end{DoxyCompactItemize}
